<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Globe Experience</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500&display=swap');
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Inter', sans-serif;
    }
    
    :root {
      --text-color: #ffffff;
      --background-color: #000000;
      --accent-color: #ff0000;
      --hover-color: rgba(0, 70, 150, 0.3);
    }
    
    body {
      background-color: var(--background-color);
      color: var(--text-color);
      overflow: hidden;
      transition: background-color 0.5s ease;
    }
    
    body.light-theme {
      --text-color: #000000;
      --background-color: #ffffff;
      --accent-color: #ff0000;
      --hover-color: rgba(100, 150, 255, 0.2);
    }
    
    #container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }
    
    #container:hover {
      background: radial-gradient(circle at var(--mouse-x) var(--mouse-y), 
                  var(--hover-color), transparent 50%);
    }
    
    #location-info {
      position: absolute;
      top: 24px;
      left: 24px;
      z-index: 10;
    }
    
    #city {
      font-size: 14px;
      opacity: 0.7;
    }
    
    #time {
      font-size: 48px;
      font-weight: 700;
      line-height: 1;
    }
    
    #main-nav {
      position: absolute;
      top: 30px;
      right: 30px;
      display: flex;
      gap: 30px;
      z-index: 10;
    }
    
    #main-nav a {
      color: var(--text-color);
      text-decoration: none;
      font-size: 14px;
      letter-spacing: 1px;
      transition: opacity 0.3s;
    }
    
    #main-nav a:hover {
      opacity: 0.7;
    }
    
    #theme-toggle {
      background: none;
      border: none;
      color: var(--text-color);
      font-size: 18px;
      cursor: pointer;
      transition: transform 0.3s;
    }
    
    #theme-toggle:hover {
      transform: rotate(30deg);
    }
    
    #date-display {
      position: absolute;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 14px;
      opacity: 0.7;
      z-index: 10;
    }
    
    #loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: var(--background-color);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      color: var(--text-color);
      gap: 20px;
    }
    
    .spinner {
      width: 40px;
      height: 40px;
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      border-top-color: var(--text-color);
      animation: spin 1s ease-in-out infinite;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* Modal sections */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.9);
      z-index: 100;
      padding: 80px 20px 20px;
      overflow-y: auto;
    }
    
    .modal-content {
      max-width: 800px;
      margin: 0 auto;
      color: var(--text-color);
    }
    
    .modal-content h1 {
      font-size: 32px;
      margin-bottom: 20px;
      font-weight: 300;
    }
    
    .modal-content p {
      font-size: 16px;
      line-height: 1.6;
      margin-bottom: 20px;
      font-weight: 300;
    }
    
    .close-button {
      position: absolute;
      top: 20px;
      right: 20px;
      background: none;
      border: none;
      color: var(--text-color);
      font-size: 24px;
      cursor: pointer;
    }
    
    /* Light theme adjustments */
    body.light-theme .spinner {
      border: 3px solid rgba(0, 0, 0, 0.3);
      border-top-color: var(--text-color);
    }
    
    body.light-theme .modal {
      background-color: rgba(255, 255, 255, 0.9);
    }
  </style>
</head>
<body>
  <div id="container">
    <div id="location-info">
      <div id="city">Loading location...</div>
      <div id="time">00:00:00</div>
    </div>

    <nav id="main-nav">
      <a href="#about">ABOUT</a>
      <a href="#work">WORK</a>
      <button id="theme-toggle" aria-label="Toggle theme">☀️</button>
    </nav>

    <div id="date-display"></div>

    <div id="loading">
      <div class="spinner"></div>
      <div>Loading globe...</div>
    </div>
  </div>

  <!-- Load Three.js from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

  <script>
    // Main application script
    document.addEventListener('DOMContentLoaded', () => {
      console.log('Document loaded, initializing application...');
      
      // Global variables
      let scene, camera, renderer, controls;
      let earth, atmosphere, locationMarker;
      let isGlobeInitialized = false;
      let userLocation = null;
      
      // DOM elements
      const container = document.getElementById('container');
      const loadingElement = document.getElementById('loading');
      const cityElement = document.getElementById('city');
      const timeElement = document.getElementById('time');
      const dateElement = document.getElementById('date-display');
      const themeToggle = document.getElementById('theme-toggle');
      
      // Initialize the application
      init();
      
      // Main initialization function
      function init() {
        console.log('Initializing 3D scene...');
        initScene();
        initEventListeners();
        getUserLocation();
        animate();
      }
      
      // Initialize Three.js scene
      function initScene() {
        try {
          // Create scene
          scene = new THREE.Scene();
          
          // Create camera
          camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
          camera.position.z = 2;
          
          // Create renderer
          renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
          renderer.setSize(window.innerWidth, window.innerHeight);
          renderer.setPixelRatio(window.devicePixelRatio);
          container.appendChild(renderer.domElement);
          
          // Add lights
          const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
          scene.add(ambientLight);
          
          const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
          directionalLight.position.set(5, 5, 5);
          scene.add(directionalLight);
          
          // Add orbit controls
          controls = new THREE.OrbitControls(camera, renderer.domElement);
          controls.enableDamping = true;
          controls.dampingFactor = 0.05;
          controls.rotateSpeed = 0.5;
          controls.minDistance = 1.5;
          controls.maxDistance = 4;
          controls.autoRotate = true;
          controls.autoRotateSpeed = 0.5;
          
          // Create stars
          createStars();
          
          // Create the globe
          createGlobe();
          
          console.log('Scene initialized successfully');
        } catch (error) {
          console.error('Error initializing scene:', error);
          loadingElement.innerHTML = `<div>Error loading globe: ${error.message}</div>`;
        }
      }
      
      // Create stars background
      function createStars() {
        try {
          const starsGeometry = new THREE.BufferGeometry();
          const starsMaterial = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 0.1,
            transparent: true
          });
          
          const starsVertices = [];
          for (let i = 0; i < 3000; i++) {
            const x = (Math.random() - 0.5) * 2000;
            const y = (Math.random() - 0.5) * 2000;
            const z = (Math.random() - 0.5) * 2000;
            starsVertices.push(x, y, z);
          }
          
          starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
          const stars = new THREE.Points(starsGeometry, starsMaterial);
          scene.add(stars);
          console.log('Stars created successfully');
        } catch (error) {
          console.error('Error creating stars:', error);
        }
      }
      
      // Create the globe with texture
      function createGlobe() {
        try {
          // Create a group for the globe
          const globeGroup = new THREE.Group();
          scene.add(globeGroup);
          
          // Create atmosphere
          const atmosphereGeometry = new THREE.SphereGeometry(1.1, 64, 64);
          const atmosphereMaterial = new THREE.MeshStandardMaterial({
            color: 0x444444,
            transparent: true,
            opacity: 0.3,
            side: THREE.BackSide
          });
          atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
          globeGroup.add(atmosphere);
          
          // Create a simple globe with a dark color
          const globeGeometry = new THREE.SphereGeometry(1, 64, 64);
          const globeMaterial = new THREE.MeshStandardMaterial({
            color: 0x222222,
            roughness: 0.8,
            metalness: 0.2,
          });
          
          earth = new THREE.Mesh(globeGeometry, globeMaterial);
          globeGroup.add(earth);
          
          // Mark as initialized
          isGlobeInitialized = true;
          
          // Hide loading screen
          loadingElement.style.display = 'none';
          
          // If we already have user location, add the marker
          if (userLocation) {
            addLocationMarker(userLocation.latitude, userLocation.longitude);
          }
          
          console.log('Globe created successfully');
        } catch (error) {
          console.error('Error creating globe:', error);
          loadingElement.innerHTML = `<div>Error creating globe: ${error.message}</div>`;
        }
      }
      
      // Convert latitude and longitude to 3D position
      function latLongToVector3(lat, long, radius) {
        const phi = (90 - lat) * (Math.PI / 180);
        const theta = (long + 180) * (Math.PI / 180);
        
        const x = -(radius * Math.sin(phi) * Math.cos(theta));
        const z = radius * Math.sin(phi) * Math.sin(theta);
        const y = radius * Math.cos(phi);
        
        return new THREE.Vector3(x, y, z);
      }
      
      // Add user location marker to the globe
      function addLocationMarker(lat, long) {
        try {
          // Store user location
          userLocation = { latitude: lat, longitude: long };
          
          // If globe isn't ready yet, return and wait for it to initialize
          if (!isGlobeInitialized) {
            console.log('Globe not initialized yet, marker will be added when ready');
            return;
          }
          
          console.log(`Adding location marker at lat: ${lat}, long: ${long}`);
          
          // Remove existing marker if any
          if (locationMarker) {
            scene.remove(locationMarker);
          }
          
          // Create marker group
          locationMarker = new THREE.Group();
          
          // Calculate position
          const position = latLongToVector3(lat, long, 1.01);
          
          // Create marker
          const markerGeometry = new THREE.SphereGeometry(0.01, 16, 16);
          const markerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
          const marker = new THREE.Mesh(markerGeometry, markerMaterial);
          
          // Create glow effect
          const glowGeometry = new THREE.SphereGeometry(0.015, 16, 16);
          const glowMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xff0000,
            transparent: true,
            opacity: 0.5
          });
          const glow = new THREE.Mesh(glowGeometry, glowMaterial);
          
          // Add marker and glow to group
          locationMarker.add(marker);
          locationMarker.add(glow);
          
          // Position the marker group
          locationMarker.position.copy(position);
          
          // Add to scene
          scene.add(locationMarker);
          console.log('Location marker added successfully');
        } catch (error) {
          console.error('Error adding location marker:', error);
        }
      }
      
      // Get user's location
      async function getUserLocation() {
        try {
          console.log('Getting user location...');
          
          // First try to get location from browser geolocation
          if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
              async (position) => {
                const { latitude, longitude } = position.coords;
                console.log(`Got coordinates: lat ${latitude}, long ${longitude}`);
                
                const locationInfo = await getLocationInfo(latitude, longitude);
                updateLocationDisplay(locationInfo);
                addLocationMarker(latitude, longitude);
              },
              async (error) => {
                console.log("Geolocation error:", error);
                await fallbackToIpLocation();
              }
            );
          } else {
            console.log("Geolocation not supported");
            await fallbackToIpLocation();
          }
        } catch (error) {
          console.error("Error in getUserLocation:", error);
          fallbackToTimezone();
        }
      }
      
      // Fallback to IP-based location
      async function fallbackToIpLocation() {
        try {
          console.log('Falling back to IP-based location...');
          const response = await fetch('https://ipapi.co/json/');
          const data = await response.json();
          
          if (data.latitude && data.longitude) {
            console.log(`Got IP location: ${data.city}, ${data.country_name}`);
            
            const locationInfo = {
              city: data.city,
              country: data.country_name,
              coordinates: [data.longitude, data.latitude],
              timezone: data.timezone
            };
            
            updateLocationDisplay(locationInfo);
            addLocationMarker(data.latitude, data.longitude);
          } else {
            throw new Error("Could not get location from IP");
          }
        } catch (ipError) {
          console.error("IP location error:", ipError);
          fallbackToTimezone();
        }
      }
      
      // Final fallback to browser timezone
      function fallbackToTimezone() {
        try {
          console.log('Falling back to timezone-based location...');
          const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
          const city = timezone.split("/").pop().replace("_", " ");
          
          const locationInfo = {
            city: city,
            country: "",
            coordinates: [0, 0],
            timezone: timezone
          };
          
          updateLocationDisplay(locationInfo);
          addLocationMarker(0, 0);
        } catch (error) {
          console.error("Timezone fallback error:", error);
          cityElement.textContent = "Location unavailable";
        }
      }
      
      // Get location info from coordinates
      async function getLocationInfo(latitude, longitude) {
        try {
          console.log('Getting location info from coordinates...');
          const response = await fetch(
            `https://api.bigdatacloud.net/data/reverse-geocode-client?latitude=${latitude}&longitude=${longitude}&localityLanguage=en`
          );
          
          if (!response.ok) {
            throw new Error("Failed to fetch location data");
          }
          
          const data = await response.json();
          console.log('Got location data:', data);
          
          return {
            city: data.city || data.locality || "Unknown City",
            country: data.countryName || "Unknown Country",
            coordinates: [longitude, latitude],
            timezone: Intl.DateTimeFormat().resolvedOptions().timeZone
          };
        } catch (error) {
          console.error("Error in getLocationInfo:", error);
          
          // Fallback to browser timezone
          const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
          const city = timezone.split("/").pop().replace("_", " ");
          
          return {
            city: city,
            country: "",
            coordinates: [longitude, latitude],
            timezone: timezone
          };
        }
      }
      
      // Update the UI with location and time
      function updateLocationDisplay(locationData) {
        try {
          console.log('Updating location display...');
          
          // Update city and country display
          if (locationData.country) {
            cityElement.textContent = `${locationData.city}, ${locationData.country}`;
          } else {
            cityElement.textContent = locationData.city;
          }
          
          // Start updating time
          updateTime();
          
          // Update time every second
          setInterval(updateTime, 1000);
          
          console.log('Location display updated successfully');
        } catch (error) {
          console.error("Error updating location display:", error);
        }
      }
      
      // Update time display
      function updateTime() {
        try {
          const now = new Date();
          
          // Format time (HH:MM:SS)
          const timeOptions = {
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit",
            hour12: false
          };
          
          // Format date (Day, Month DD HH:MM:SS AM/PM)
          const dateOptions = {
            weekday: "short",
            month: "short",
            day: "2-digit",
            hour: "numeric",
            minute: "2-digit",
            second: "2-digit",
            hour12: true
          };
          
          // Use the user's timezone if available
          const formatter = new Intl.DateTimeFormat("en-US", timeOptions);
          const dateFormatter = new Intl.DateTimeFormat("en-US", dateOptions);
          
          timeElement.textContent = formatter.format(now);
          dateElement.textContent = dateFormatter.format(now);
        } catch (error) {
          console.error("Error updating time:", error);
        }
      }
      
      // Handle window resize
      function onWindowResize() {
        try {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        } catch (error) {
          console.error("Error handling window resize:", error);
        }
      }
      
      // Animation loop
      function animate() {
        try {
          requestAnimationFrame(animate);
          
          // Update controls
          controls.update();
          
          // Render scene
          renderer.render(scene, camera);
        } catch (error) {
          console.error("Error in animation loop:", error);
        }
      }
      
      // Update theme colors
      function updateTheme(isLightTheme) {
        try {
          if (atmosphere) {
            if (isLightTheme) {
              atmosphere.material.color.set(0xaaaaaa);
            } else {
              atmosphere.material.color.set(0x444444);
            }
          }
          
          if (locationMarker) {
            const marker = locationMarker.children[0];
            const glow = locationMarker.children[1];
            
            if (isLightTheme) {
              marker.material.color.set(0xff0000);
              glow.material.color.set(0xff0000);
            } else {
              marker.material.color.set(0xff0000);
              glow.material.color.set(0xff0000);
            }
          }
        } catch (error) {
          console.error("Error updating theme:", error);
        }
      }
      
      // Initialize event listeners
      function initEventListeners() {
        try {
          // Window resize
          window.addEventListener('resize', onWindowResize);
          
          // Theme toggle
          themeToggle.addEventListener('click', () => {
            const body = document.body;
            const isLightTheme = body.classList.toggle('light-theme');
            
            // Update theme icon
            themeToggle.textContent = isLightTheme ? '🌙' : '☀️';
            
            // Update globe colors
            updateTheme(isLightTheme);
          });
          
          // Mouse move effect for blue organic hue
          document.addEventListener('mousemove', (e) => {
            document.documentElement.style.setProperty('--mouse-x', `${e.clientX}px`);
            document.documentElement.style.setProperty('--mouse-y', `${e.clientY}px`);
          });
          
          // Modal functionality for About and Work sections
          const aboutLink = document.querySelector('a[href="#about"]');
          const workLink = document.querySelector('a[href="#work"]');
          
          // Create modals
          createModal('about', 'About', `
            <p>Under Construction</p>
          `);
          
          createModal('work', 'Work', `
            <p>Under Construction</p>
          
          `);
          
          // Add event listeners for modal links
          aboutLink.addEventListener('click', (e) => {
            e.preventDefault();
            document.getElementById('about-modal').style.display = 'block';
          });
          
          workLink.addEventListener('click', (e) => {
            e.preventDefault();
            document.getElementById('work-modal').style.display = 'block';
          });
          
          console.log('Event listeners initialized successfully');
        } catch (error) {
          console.error("Error initializing event listeners:", error);
        }
      }
      
      // Helper function to create modals
      function createModal(id, title, content) {
        try {
          const modal = document.createElement('div');
          modal.id = `${id}-modal`;
          modal.className = 'modal';
          
          modal.innerHTML = `
            <button class="close-button">&times;</button>
            <div class="modal-content">
              <h1>${title}</h1>
              ${content}
            </div>
          `;
          
          document.body.appendChild(modal);
          
          // Add close functionality
          modal.querySelector('.close-button').addEventListener('click', () => {
            modal.style.display = 'none';
          });
          
          // Close when clicking outside content
          modal.addEventListener('click', (e) => {
            if (e.target === modal) {
              modal.style.display = 'none';
            }
          });
        } catch (error) {
          console.error(`Error creating ${id} modal:`, error);
        }
      }
    });
  </script>
</body>
</html>